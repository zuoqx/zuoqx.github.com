---
layout: post
title: Android性能优化
description: Android性能优化
category: blog
---


### 渲染性能  
1. 大多数用户感知到的卡顿等性能问题的最主要根源都是因为渲染性能。  
2. Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都能在16ms内成功，即Frame Rate为60fps，为了能够实现60fps，样就能够达到流畅的画面。  
3. 如果某次渲染操作超过16ms，这样就会发生丢帧现象。常见的比如ListView滑动是由于丢帧而感知的卡顿不流畅现象。  

### 过度绘制  
1. Overdraw(过度绘制)：描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，就会导致某些像素区域被绘制了多次。这就浪费大量的CPU以及GPU资源。  
2. 通过手机设置里面的开发者选项，ShowGPU verdraw的选项，观察UI上的Overdraw情况。    
![过度绘制](/images/overdraw_options_view.png)    
3. 过度绘制的原因：一是因为UI布局存在大量重叠的部分，二是因为非必须的重叠背景（比如某个Activity有一个背景，然后里面的Layout又有自己的背景，同时子View又分别有自己的背景。）。  

### 理解VSYNC信号量  
1. 名词解释：   
Refresh Rate：代表了机器在一秒内刷新屏幕的次数，取决于硬件的固定参数，例如60Hz。  
Frame Rate：代表了GPU在一秒内绘制操作的帧数，例如30fps，60fps。   
2. GPU会获取图形数据进行渲染，然后硬件负责把渲染后的内容呈现到屏幕上，他们两者不停的进行协作。  
3. 如果帧率与刷新频率不一致，就会容易出现Tearing的现象(画面上下两部分显示内容发生断裂，来自不同的两帧数据发生重叠)。  
4. 帧率从超过60fps突然掉到60fps以下，这样就会发生LAG，JANK，HITCHING等卡顿掉帧的不顺滑的情况。这也是用户感受不好的原因所在。  

### 为什么是60fps  
1. 因为人眼与大脑之间的协作无法感知超过60fps的画面更新。 
2. 12fps大概类似手动快速翻动书籍的帧率，这明显是可以感知到不够顺滑的。24fps使得人眼感知的是连续线性的运动，这其实是归功于运动模糊的效果。24fps是电影胶圈通常使用的帧率，因为这个帧率已经足够支撑大部分电影画面需要表达的内容，同时能够最大的减少费用支出。但是低于30fps是无法顺畅表现绚丽的画面内容的，此时就需要用到60fps来达到想要的效果，当然超过60fps是没有必要的。  
3. 开发app的性能目标就是保持60fps，这意味着每一帧你只有16ms=1000/60的时间来处理所有的任务。  

### activity的画面是如何绘制到屏幕上的 ？  
1. CPU负责把UI组件计算成Polygons（多边形），Texture纹理，然后交给GPU进行栅格化渲染，然后CPU显示到屏幕上。  
2. 为了能够使得App流畅，我们需要在每一帧16ms以内处理完所有的CPU与GPU计算，绘制，渲染等等操作。  
3. 文字的显示更加复杂，需要先经过CPU换算成纹理，然后再交给GPU进行渲染，回到CPU绘制单个字符的时候，再重新引用经过GPU渲染的内容。  
4. Android系统是如何处理UI组件的更新操作的：Android需要把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。

在某个View第一次需要被渲染时，DisplayList会因此而被创建，当这个View要显示到屏幕上时，我们会执行GPU的绘制指令来进行渲染。如果你在后续有执行类似移动这个View的位置等操作而需要再次渲染这个View时，我们就仅仅需要额外操作一次渲染指令就够了。然而如果你修改了View中的某些可见组件，那么之前的DisplayList就无法继续使用了，我们需要回头重新创建一个DisplayList并且重新执行渲染指令并更新到屏幕上。

需要注意的是：任何时候View中的绘制内容发生变化时，都会重新执行创建DisplayList，渲染DisplayList，更新到屏幕上等一系列操作。这个流程的表现性能取决于你的View的复杂程度，View的状态变化以及渲染管道的执行性能。举个例子，假设某个Button的大小需要增大到目前的两倍，在增大Button大小之前，需要通过父View重新计算并摆放其他子View的位置。修改View的大小会触发整个HierarcyView的重新计算大小的操作。如果是修改View的位置则会触发HierarchView重新计算其他View的位置。如果布局很复杂，这就会很容易导致严重的性能问题。我们需要尽量减少Overdraw。  

### 自定义View(重写了onDraw方法)中如何避免过度绘制：  、
1. 使用canvas.clipRect()来帮助系统识别那些可见的区域：这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。  
2. 使用canvas.quickreject()来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。  

### 内存抖动和性能  
1. Android系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后到Permanent Generation区域。  
2. 执行GC操作的时候，所有线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行  
3. 导致GC频繁执行有两个原因：

    Memory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。  
    瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。  
4. 在短时间内，同一个栈中不断进出的相同对象。这是内存抖动的典型信号之一  
5. 避免在for循环里面分配对象占用内存，需要尝试把对象的创建移到循环体之外  
6. 自定义View中的onDraw方法也需要引起注意，每次屏幕发生绘制以及动画执行过程中，onDraw方法都会被调用到，避免在onDraw方法里面执行复杂的操作，避免创建对象。对于那些无法避免需要创建对象的情况，我们可以考虑对象池模型，通过对象池来解决频繁创建与销毁的问题，但是这里需要注意结束使用之后，需要手动释放对象池中的对象。  

### 内存泄漏  
1. 内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了宝贵的内存空间。显然，这还使得每级Generation的内存区域可用空间变小，GC就会更容易被触发，从而引起性能问题。  

### Android是如何管理内存的  
Android没有为内存提供交换区(Swap space)，但是它有使用paging与memory-mapping(mmapping)的机制来管理内存。这意味着任何你修改的内存(无论是通过分配新的对象还是去访问mmaped pages中的内容)都会贮存在RAM中，而且不能被paged out。唯一完整释放内存的方法是释放那些你可能持有的对象的引用，当这个对象没有被任何其他对象所引用的时候，它就能够被GC回收了。只有一种例外是：如果系统想要在其他地方重用这个对象。

## 共享内存  
Android通过下面几个方式在不同的进程中来实现共享RAM:  
1. 每一个app的进程都是从Zygote的进程中fork出来的。Zygote进程是在系统启动并且载入通用的framework的代码和资源之后开始启动的。为了启动一个新的App进程，系统会fork Zygote进程生成一个新的进程，然后在新的进程中加载并运行App的代码。这使得大多数的RAM pages被用来分配给framework的代码，所以RAM系统资源能够在应用的所有进程中进行共享。  
2. 大多数static的数据被mmapped到一个进程中。这不仅仅使得同样的数据能够在进程间进行共享，而且使得它能够在需要的时候被paged out。例如下面几种static的数据:  
* Dalvik 代码 (放在一个预链接好的 .odex 文件中以便直接mapping)
* App resources (通过把资源表结构设计成便于mmapping的数据结构，另外还可以通过把APK中的文件做aligning的操作来优化)
* 传统项目元素，比如 .so 文件中的本地代码.  
3. 在很多情况下，Android通过显式的分配共享内存区域(例如ashmem或者gralloc)来实现一些动态RAM区域能够在不同进程间进行共享。例如，window surfaces在app与screen compositor之间使用共享的内存，cursor buffers在content provider与client之间使用共享的内存。

## 分配与回收内存  
1. 每一个进程的Dalvik heap都有一个受限的虚拟内存范围。这就是逻辑上讲的heap size，可以根据需要进行扩充，但是会有一个系统上限。  
2. 逻辑上讲的heap size和实际物理上使用的内存数量是不相等的，Android会计算一个叫做Proportional Set Size(PSS)的值，PSS记录了那些和其他进程共享的内存大小。（假设共享内存大小是10M，一共有20个Process在共享使用，根据权重，可能认为其中有0.3M才能真正算是你的进程所使用的）  
3. Dalvik heap与逻辑上的heap size不吻合，这意味着Android并不会去做heap中的碎片整理用来关闭空闲区域。Android仅仅会在heap的尾端出现不使用的空间时才会做收缩逻辑heap size大小的动作。但是这并不是意味着被heap所使用的物理内存大小不能被收缩。在垃圾回收之后，Dalvik会遍历heap并找出不使用的pages，然后使用madvise(系统调用)把那些pages返回给kernal。因此，成对的allocations与deallocations大块的数据可以使得物理内存能够被正常的回收。然而，回收碎片化的内存则会使得效率低下很多，因为那些碎片化的分配页面也许会被其他地方所共享到。  
## 应用内存的上限  
1. 为了维持多任务的功能环境，Android为每一个app都设置了一个heap size的上限。具体的heap size限制因不同设备、不同RAM大小而各有差异。如果app已经到了heap的限制大小并且再尝试分配内存的话，会引起OutOfMemoryError的错误。  
2. 可以通过getMemoryClass()来查询当前设备的heap size限制大小是多少。 

## 切换应用  
1. Android并不会在用户切换不同应用时候做交换内存的操作。Android会把那些不包含foreground组件的进程放到LRU cache中。例如，当用户刚开始启动了一个应用，系统会为它创建了一个进程，但是当用户离开这个应用，此进程并不会立即被销毁。系统会把这个进程放到cache中，如果用户后来再回到这个应用，此进程就能够被完整恢复，从而实现应用的快速切换。  
2. 当系统开始进入低内存状态时，它会由系统根据LRU的规则与其他因素选择综合考虑之后决定杀掉某些进程，回收一些内存。  

### 应用该如何管理内存   
1. 正确使用Service  
* 当你启动一个service，系统会倾向为了保留这个service而一直保留service所在的进程。
* 当Service不执行任务时，记得停止掉。 
* 使用IntentService， 它会在处理完交代给它的intent任务之后尽快结束自己。
2. 当UI隐藏时释放内存  
    当用户切换到其它应用并且你的应用 UI不再可见时，你应该释放你的应用UI上所占用的所有内存资源。为了能够接收到用户离开你的UI时的通知，需要实现Activtiy类里面的onTrimMemory()回调方法来监听到TRIM_MEMORY_UI_HIDDEN级别的回调，此时意味着UI已经隐藏，应该释放那些仅仅被你的UI使用的资源。
3. 当内存紧张时释放部分内存  
    在你的app生命周期的任何阶段，onTrimMemory的回调方法同样可以告诉你整个设备的内存资源已经开始紧张。你应该根据onTrimMemory回调中的内存级别来进一步决定释放哪些资源。
4. 避免bitmaps的浪费
    当你加载一个bitmap时，仅仅需要保留适配当前屏幕设备分辨率的数据即可，如果原图高于你的设备分辨率，需要做缩小的动作。请记住，增加bitmap的尺寸会对内存呈现出2次方的增加，因为X与Y都在增加。
5. 使用优化的数据容器
    利用Android Framework里面优化过的容器类，例如SparseArray, SparseBooleanArray, 与 LongSparseArray。 通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效在于他们避免了对key与value的autobox自动装箱，并且避免了装箱后的解箱。
6. 请注意内存开销  
* Enums的内存消耗通常是static constants的2倍。你应该尽量避免在Android上使用enums。
* 在Java中的每一个类(包括匿名内部类)都会使用大概500 bytes。
* 每一个类的实例花销是12-16 bytes。
* 往HashMap添加一个entry需要额一个额外占用的32 bytes的entry对象。
7. 避免使用依赖注入框架
    那些框架会通过扫描你的代码执行许多初始化的操作，这会导致你的代码需要大量的RAM来mapping代码，而且mapped pages会长时间的被保留在RAM中。  
8. 谨慎使用第三方libraries  
9. 使用ProGuard来剔除不需要的代码  
10. 对最终的APK使用zipalign  

### 性能监测根据  
## traceview   
1. TraceView工具能做什么？  
    简单一点来说就是我们能找到频繁被调用的方法，也能找到执行非常耗时的方法，前者可能会造成Cpu频繁调用，手机发烫的问题，后者就是卡顿的问题
2. traceview中两种方法
    inclusive time：指方法执行时间以及内部其他方法执行时间之和
    exclusive time：指方法本身执行时间
3. traceview面板：
    Parents:调用该方法的父类方法
    Children:该方法调用的子类方法
4. https://www.kancloud.cn/digest/itfootballprefermanc/100911









