---
layout: post
title: Android性能优化
description: Android性能优化
category: blog
---


### 渲染性能  
1. 大多数用户感知到的卡顿等性能问题的最主要根源都是因为渲染性能。  
2. Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都能在16ms内成功，即Frame Rate为60fps，为了能够实现60fps，样就能够达到流畅的画面。  
3. 如果某次渲染操作超过16ms，这样就会发生丢帧现象。常见的比如ListView滑动是由于丢帧而感知的卡顿不流畅现象。  

### 过度绘制  
1. Overdraw(过度绘制)：描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，就会导致某些像素区域被绘制了多次。这就浪费大量的CPU以及GPU资源。  
2. 通过手机设置里面的开发者选项，ShowGPU verdraw的选项，观察UI上的Overdraw情况。    
![过度绘制](/images/overdraw_options_view.png)    
3. 过度绘制的原因：一是因为UI布局存在大量重叠的部分，二是因为非必须的重叠背景（比如某个Activity有一个背景，然后里面的Layout又有自己的背景，同时子View又分别有自己的背景。）。  

### 理解VSYNC信号量  
1. 名词解释：   
Refresh Rate：代表了机器在一秒内刷新屏幕的次数，取决于硬件的固定参数，例如60Hz。  
Frame Rate：代表了GPU在一秒内绘制操作的帧数，例如30fps，60fps。   
2. GPU会获取图形数据进行渲染，然后硬件负责把渲染后的内容呈现到屏幕上，他们两者不停的进行协作。  
3. 如果帧率与刷新频率不一致，就会容易出现Tearing的现象(画面上下两部分显示内容发生断裂，来自不同的两帧数据发生重叠)。  
4. 帧率从超过60fps突然掉到60fps以下，这样就会发生LAG，JANK，HITCHING等卡顿掉帧的不顺滑的情况。这也是用户感受不好的原因所在。  

### 为什么是60fps  
1. 因为人眼与大脑之间的协作无法感知超过60fps的画面更新。 
2. 12fps大概类似手动快速翻动书籍的帧率，这明显是可以感知到不够顺滑的。24fps使得人眼感知的是连续线性的运动，这其实是归功于运动模糊的效果。24fps是电影胶圈通常使用的帧率，因为这个帧率已经足够支撑大部分电影画面需要表达的内容，同时能够最大的减少费用支出。但是低于30fps是无法顺畅表现绚丽的画面内容的，此时就需要用到60fps来达到想要的效果，当然超过60fps是没有必要的。  
3. 开发app的性能目标就是保持60fps，这意味着每一帧你只有16ms=1000/60的时间来处理所有的任务。  

### activity的画面是如何绘制到屏幕上的 ？  
1. CPU负责把UI组件计算成Polygons（多边形），Texture纹理，然后交给GPU进行栅格化渲染，然后CPU显示到屏幕上。  
2. 为了能够使得App流畅，我们需要在每一帧16ms以内处理完所有的CPU与GPU计算，绘制，渲染等等操作。  
3. 文字的显示更加复杂，需要先经过CPU换算成纹理，然后再交给GPU进行渲染，回到CPU绘制单个字符的时候，再重新引用经过GPU渲染的内容。  
4. Android系统是如何处理UI组件的更新操作的：Android需要把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。

在某个View第一次需要被渲染时，DisplayList会因此而被创建，当这个View要显示到屏幕上时，我们会执行GPU的绘制指令来进行渲染。如果你在后续有执行类似移动这个View的位置等操作而需要再次渲染这个View时，我们就仅仅需要额外操作一次渲染指令就够了。然而如果你修改了View中的某些可见组件，那么之前的DisplayList就无法继续使用了，我们需要回头重新创建一个DisplayList并且重新执行渲染指令并更新到屏幕上。

需要注意的是：任何时候View中的绘制内容发生变化时，都会重新执行创建DisplayList，渲染DisplayList，更新到屏幕上等一系列操作。这个流程的表现性能取决于你的View的复杂程度，View的状态变化以及渲染管道的执行性能。举个例子，假设某个Button的大小需要增大到目前的两倍，在增大Button大小之前，需要通过父View重新计算并摆放其他子View的位置。修改View的大小会触发整个HierarcyView的重新计算大小的操作。如果是修改View的位置则会触发HierarchView重新计算其他View的位置。如果布局很复杂，这就会很容易导致严重的性能问题。我们需要尽量减少Overdraw。  

### 自定义View(重写了onDraw方法)中如何避免过度绘制：  、
1. 使用canvas.clipRect()来帮助系统识别那些可见的区域：这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。  
2. 使用canvas.quickreject()来判断是否没和某个矩形相交，从而跳过那些非矩形区域内的绘制操作。  

### 内存抖动和性能  
1. Android系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后到Permanent Generation区域。  
2. 执行GC操作的时候，所有线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行  
3. 导致GC频繁执行有两个原因：

    Memory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。  
    瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。  
4. 在短时间内，同一个栈中不断进出的相同对象。这是内存抖动的典型信号之一  
5. 避免在for循环里面分配对象占用内存，需要尝试把对象的创建移到循环体之外  
6. 自定义View中的onDraw方法也需要引起注意，每次屏幕发生绘制以及动画执行过程中，onDraw方法都会被调用到，避免在onDraw方法里面执行复杂的操作，避免创建对象。对于那些无法避免需要创建对象的情况，我们可以考虑对象池模型，通过对象池来解决频繁创建与销毁的问题，但是这里需要注意结束使用之后，需要手动释放对象池中的对象。  

### 内存泄漏  
1. 内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了宝贵的内存空间。显然，这还使得每级Generation的内存区域可用空间变小，GC就会更容易被触发，从而引起性能问题。  

### Android是如何管理内存的  
Android没有为内存提供交换区(Swap space)，但是它有使用paging与memory-mapping(mmapping)的机制来管理内存。这意味着任何你修改的内存(无论是通过分配新的对象还是去访问mmaped pages中的内容)都会贮存在RAM中，而且不能被paged out。唯一完整释放内存的方法是释放那些你可能持有的对象的引用，当这个对象没有被任何其他对象所引用的时候，它就能够被GC回收了。只有一种例外是：如果系统想要在其他地方重用这个对象。  
## 共享内存  










