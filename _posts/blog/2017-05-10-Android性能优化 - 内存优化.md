---
layout: post
title: Android性能优化-内存优化
description: Android性能优化-内存优化
category: blog
---


# Android中的内存模型（内存分配）
**内存**，即Random Access Memory(RAM)，Android并没有为内存提供交换区(Swap space)，但是它有使用paging与memory-mapping(mmapping)的机制来管理内存。这意味着任何你修改的内存(无论是通过分配新的对象还是去访问mmaped pages中的内容)都会保存在RAM中，而且不能被paged out。因此唯一完整释放内存的方法是释放那些你可能持有的对象的引用，当这个对象没有被任何其他对象所引用的时候，它就能够被GC回收了。只有一种例外是：如果系统想要在其他地方重用这个对象。
    
## Dalvik虚拟机中的内存模型   
Android应用程序是运行在Dalvik虚拟机里面的，并且每一个应用程序对应有一个单独的Dalvik虚拟机实例。   

###Dalvik虚拟机和Java虚拟机的区别和联系
  
* Dalvik虚拟机与Java虚拟机的最显著区别是它们分别具有不同的类文件格式以及指令集。Dalvik虚拟机使用的是dex（Dalvik Executable）格式的类文件，而Java虚拟机使用的是class格式的类文件。一个dex文件可以包含若干个类，而一个class文件只包括一个类。由于一个dex文件可以包含若干个类，因此它就可以将各个类中重复的字符串和其它常数只保存一次，从而节省了空间。
* 
* Dalvik虚拟机使用的指令是基于寄存器的，而Java虚拟机使用的指令集是基于堆栈的。例如，Java虚拟机使用的指令只占一个字节，因而称为字节码。基于寄存器的指令由于需要指定源地址和目标地址，因此需要占用更多的指令空间，例如，Dalvik虚拟机的某些指令需要占用两个字节。基于堆栈和基于寄存器的指令集各有优劣，一般而言，执行同样的功能，前者需要更多的指令（主要是load和store指令），而后者需要更多的指令空间。需要更多指令意味着要多占用CPU时间，而需要更多指令空间意味着数据缓冲（d-cache）更易失效。

* 基于堆栈的指令更具可移植性，因为它不对目标机器的寄存器进行任何假设。然而，基于寄存器的指令由于对目标机器的寄存器进行了假设，因此，它更有利于进行AOT（ahead-of-time）优化。所谓AOT，就是在解释语言程序运行之前，就先将它编译成本地机器语言程序。AOT本质上是一种静态编译，它是相对于JIT而言的，也就是说，前者是在程序运行前进行编译，而后者是在程序运行时进行编译。运行时编译意味着可以利用运行时信息来得到比较静态编译更优化的代码，同时也意味不能进行某些高级优化，因为优化过程太耗时了。另一方面，运行前编译由于不占用程序运行时间，因此，它就可以不计时间成本来优化代码。无论AOT，还是JIT，最终的目标都是将解释语言编译为本地机器语言，而本地机器语言都是基于寄存器来执行的，因此，在某种程度来讲，基于寄存器的指令更有利于进行AOT编译以及优化。
* Dalvik虚拟机都在尽最大的努力来优化自身，这些措施包括：
>1. 将多个类文件收集到同一个dex文件中，以便节省空间；
>2. 使用只读的内存映射方式加载dex文件，以便可以多进程共享dex文件，节省程序加载时间；
>3. 提前调整好字节序（byte order）和字对齐（word alignment）方式，使得它们更适合于本地机器，以便提高指令执行速度；
>4. 尽量提前进行字节码验证（bytecode verification），提高程序的加载速度；
>5. 需要重写字节码的优化要提前进行。

###Dalvik的其他特征 
 
#### **内存管理**  

Dalvik虚拟机的内存大体上可以分为Java Object Heap、Bitmap Memory和Native Heap三种。

>**Java Object Heap**，是用来分配Java对象的，也就是我们在代码new出来的对象都是位于Java Object Heap上的。Dalvik虚拟机在启动的时候，可以通过-Xms和-Xmx选项来指定Java Object Heap的最小值和最大值。可以通过ActivityManager类的成员函数getMemoryClass来获得Dalvik虚拟机的Java Object Heap的最大值。这个Java Object Heap的最大值也就是我们平时所说的Android应用程序进程能够使用的最大内存。这里必须要注意的是，Android应用程序进程能够使用的最大内存指的是能够用来分配Java Object的堆。

> **Bitmap Memory**，也称为External Memory，它是用来处理图像的。在HoneyComb之前，Bitmap Memory是在Native Heap中分配的，但是这部分内存同样计入Java Object Heap中。 在HoneyComb以及更高的版本中，Bitmap Memory就直接是在Java Object Heap中分配了，这样就可以直接接受GC的管理。

> **Native Heap**，就是在Native Code中使用malloc等分配出来的内存，这部分内存是不受Java Object Heap的大小限制的，也就是它可以自由使用，当然它是会受到系统的限制。

> 在HoneyComb以及更高的版本中，我们可以在AndroidManifest.xml的application标签中增加一个值等于“true”的android:largeHeap属性来通知Dalvik虚拟机应用程序需要使用较大的Java Object Heap。事实上，在内存受限的手机上，即使我们将一个应用程序的android:largeHeap属性设置为“true”，也是不能增加它可用的Java Object Heap的大小的。 

####**垃圾收集(GC)**
  
Dalvik虚拟机可以自动回收那些不再使用了的Java Object，也就是那些不再被引用了的Java Object。

在GingerBread之前，Dalvik虚拟使用的垃圾收集机制有以下特点
> Stop-the-world，也就是垃圾收集线程在执行的时候，其它的线程都停止；
> Full heap collection，也就是一次收集完全部的垃圾；
> 一次垃圾收集造成的程序中止时间通常都大于100ms。

在GingerBread以及更高的版本中，Dalvik虚拟使用的垃圾收集机制得到了改进，如下所示：
> Cocurrent，也就是大多数情况下，垃圾收集线程与其它线程是并发执行的；
> Partial collection，也就是一次可能只收集一部分垃圾；
> 一次垃圾收集造成的程序中止时间通常都小于5ms。

Dalvik虚拟机执行完成一次垃圾收集之后，我们通常可以看到类似以下的日志输出：

```java
D/dalvikvm(9050): GC_CONCURRENT freed 2049K, 65% free 3571K/9991K, external 4703K/5261K, paused 2ms+2ms  
```
> 其中，GC_CONCURRENT表示GC原因，2049K表示总共回收的内存，3571K/9991K表示Java Object Heap统计，即在9991K的Java Object Heap中，有3571K是正在使用的

> 4703K/5261K表示External Memory统计，即在5261K的External Memory中，有4703K是正在使用的

> 2ms+2ms表示垃圾收集造成的程序中止时间。
  
Dalvik日志格式如下：  

| 日志项  |  回收原因 | 释放量 | 堆统计数据 | 外部内存统计数据 | 暂停时间 |
| --- | --- | --- | --- | --- | --- |
|包含内容 | **GC_CONCURRENT**：当Java Heap占用内存时并发进行垃圾回收 **GC_FOR_MALLOC**：当Java Heap已满，应用请求分配更多内存时引起的垃圾回收  **GC_HPROF_DUMP_HEAP**：当请求创建HPROP文件（Java Heap Profile)时引起的垃圾回收  **GC_EXPLICIT**：显式垃圾回收，例如当您调用 System.gc()时 **GC_EXTERNAL_ALLOC**：外部分配内存的垃圾回收（例如存储在原生内存或 NIO 字节缓冲区中的像素数据）。仅适用于 API 级别 10 及更低级别 | 从此次垃圾回收中回收的内存量 | 堆的可用空间百分比与（活动对象数量）/（堆总大小）| API 级别 10 及更低级别的外部分配内存（已分配内存量）/（发生回收的限值）| 堆越大，暂停时间越长。并发暂停时间显示了两个暂停：一个出现在回收开始时，另一个出现在回收快要完成时 | 
 
 >堆统计数据的增大（上面示例中的 3571K/9991K 值）。如果此值继续增大，可能会出现内存泄漏 

####**即时编译(JIT)**
  
JIT是相对AOT而言的，即JIT是在**程序运行**的过程中进行编译的，而AOT是在**程序运行前**进行编译的。在程序运行的过程中进行编译既有好处，也有坏处。好处在于可以利用程序的运行时信息来对编译出来的代码进行优化，而坏处在于占用程序的运行时间，也就是说不能花太多时间在代码编译和优化之上。

> JIT根据2-8原则(一个程序80%的时间可能都是在重复执行20%的代码)，可能只会选择那些热点代码进行编译或者优化。因此，JIT就可以选择这20%经常执行的代码来进行编译和优化。

> 为了充分地利用好运行时信息来优化代码，JIT采用一种激进的方法。JIT在编译代码的时候，会对程序的运行情况进行假设，并且按照这种假设来对代码进行优化。随着程序的代码，如果前面的假设一直保持成立，那么JIT就什么也不用做，因此就可以提高程序的运行性能。一旦前面的假设不再成立了，那么JIT就需要对前面编译优化的代码进行调整，以便适应新的情况。
> 比较典型的例子是，Java的同步原语涉及到Lock和Unlock操作。Lock和Unlock操作是非常耗时的，而且它们只有在多线程环境中才真的需要。但是一些同步函数或者同步代码，有程序运行的时候，有可能始终都是被单线程执行，也就是说，这些同步函数或者同步代码不会被多线程同时执行。这时候JIT就可以采取一种Lazy Unlocking机制。

> Lay Unlocking 机制：当线程T1进入同步代码C时，线程按照正常流程获取一个轻量级锁。当线程T1离开同步代码时，它并不会释放前面获得的锁。当线程T1
在此进入到同步代码时，发现同步锁是自己，因此它就可以直接执行代码C。如果其他线程进入到同步代码C时，发现同步锁已经被线程T1持有，JIT会检查T1是否2还在执行同步代码C，如果没有执行，则将该锁unlock，然后这个新的线程重新持有该锁，即调用lock原语。
  
####**Java本地调用(JNI)**
  
> 虚拟机最终都是运行在目标机器之上的，也就是说，它需要将自己的指令翻译成目标机器指令来执行，并且有些功能，需要通过调用目标机器运行的操作系统接口来完成  

> JNI机制既支持在Java函数中调用C/C++函数，也支持在C/C++函数中调用Java函数。

> Dalvik虚拟机提供的Java运行时库，大部分都是通过调用目标机器操作系统接口来实现的，也就是通过调用Linux系统接口来实现的。例如，当我们调用android.os.Process类的成员函数start来创建一个进程的时候，最终会调用到Linux系统提供的fork系统调用来创建一个进程。  

> 同时，为了方便开发者使用C/C++语言来开发应用程序，Android官方提供了NDK。通过NDK，我们就可以使用JNI机制来在Java函数中调用到C/C++函数。不过Android官方是不提倡使用NDK来开发应用程序的，这从它对NDK的支持远远不如SDK的支持就可以看得出来。  

####**进程和线程管理**

一般来说，虚拟机的进程和线程都是与目标机器本地操作系统的进程和线程一一对应的，这样做的好处是可以使本地操作系统来调度进程和线程。进程和线程调度是操作系统的核心模块，它的实现是非常复杂的，特别是考虑到多核的情况，因此，就完全没有必要在虚拟机中提供一个进程和线程库。

Dalvik虚拟机运行在Linux操作系统之上。我们知道，Linux操作系统并没有纯粹的线程概念，只要两个进程共享同一个地址空间，那么就可以认为它们同一个进程的两个线程。Linux操作系统提供了两个fork和clone两个调用，其中，前者就是用来创建进程的，而后者就是用来创建线程的。

每一个Android应用程序进程都有一个Dalvik虚拟机实例。这样做的好处是Android应用程序进程之间不会相互影响，也就是说，一个Android应用程序进程的意外中止，不会影响到其它的Android应用程序进程的正常运行。

每一个Android应用程序进程都是由一种称为Zygote的进程fork出来的。Zygote进程是由init进程启动起来的，也就是在系统启动的时候启动的。Zygote进程在启动的时候，会创建一个虚拟机实例，并且在这个虚拟机实例将所有的Java核心库都加载起来。每当Zygote进程需要创建一个Android应用程序进程的时候，它就通过复制自身来实现，也就是通过fork系统调用来实现。这些被fork出来的Android应用程序进程，一方面是复制了Zygote进程中的虚拟机实例，另一方面是与Zygote进程共享了同一套Java核心库。这样不仅Android应用程序进程的创建过程很快，而且由于所有的Android应用程序进程都共享同一套Java核心库而节省了内存空间。

Dalvik虚拟机和Java虚拟机的实现是类似的，例如，Dalvik虚拟机也支持JDWP（Java Debug Wire Protocol）协议，这样我们就可以使用DDMS来调试运行在Dalvik虚拟机中的进程。  
   
## ART中的内存模型  

### Android中垃圾回收机制  
## Dalvik VM中的垃圾回收机制  

## ART VM中的垃圾回收机制  

### Android如何优化内存  




  

### Android是如何管理内存的  
Android没有为内存提供交换区(Swap space)，但是它有使用paging与memory-mapping(mmapping)的机制来管理内存。这意味着任何你修改的内存(无论是通过分配新的对象还是去访问mmaped pages中的内容)都会贮存在RAM中，而且不能被paged out。唯一完整释放内存的方法是释放那些你可能持有的对象的引用，当这个对象没有被任何其他对象所引用的时候，它就能够被GC回收了。只有一种例外是：如果系统想要在其他地方重用这个对象。

## 共享内存  
Android通过下面几个方式在不同的进程中来实现共享RAM:  
1. 每一个app的进程都是从Zygote的进程中fork出来的。Zygote进程是在系统启动并且载入通用的framework的代码和资源之后开始启动的。为了启动一个新的App进程，系统会fork Zygote进程生成一个新的进程，然后在新的进程中加载并运行App的代码。这使得大多数的RAM pages被用来分配给framework的代码，所以RAM系统资源能够在应用的所有进程中进行共享。  
2. 大多数static的数据被mmapped到一个进程中。这不仅仅使得同样的数据能够在进程间进行共享，而且使得它能够在需要的时候被paged out。例如下面几种static的数据:  
* Dalvik 代码 (放在一个预链接好的 .odex 文件中以便直接mapping)
* App resources (通过把资源表结构设计成便于mmapping的数据结构，另外还可以通过把APK中的文件做aligning的操作来优化)
* 传统项目元素，比如 .so 文件中的本地代码.  
3. 在很多情况下，Android通过显式的分配共享内存区域(例如ashmem或者gralloc)来实现一些动态RAM区域能够在不同进程间进行共享。例如，window surfaces在app与screen compositor之间使用共享的内存，cursor buffers在content provider与client之间使用共享的内存。

## 分配与回收内存  
1. 每一个进程的Dalvik heap都有一个受限的虚拟内存范围。这就是逻辑上讲的heap size，可以根据需要进行扩充，但是会有一个系统上限。  
2. 逻辑上讲的heap size和实际物理上使用的内存数量是不相等的，Android会计算一个叫做Proportional Set Size(PSS)的值，PSS记录了那些和其他进程共享的内存大小。（假设共享内存大小是10M，一共有20个Process在共享使用，根据权重，可能认为其中有0.3M才能真正算是你的进程所使用的）  
3. Dalvik heap与逻辑上的heap size不吻合，这意味着Android并不会去做heap中的碎片整理用来关闭空闲区域。Android仅仅会在heap的尾端出现不使用的空间时才会做收缩逻辑heap size大小的动作。但是这并不是意味着被heap所使用的物理内存大小不能被收缩。在垃圾回收之后，Dalvik会遍历heap并找出不使用的pages，然后使用madvise(系统调用)把那些pages返回给kernal。因此，成对的allocations与deallocations大块的数据可以使得物理内存能够被正常的回收。然而，回收碎片化的内存则会使得效率低下很多，因为那些碎片化的分配页面也许会被其他地方所共享到。  

## 应用内存的上限  
1. 为了维持多任务的功能环境，Android为每一个app都设置了一个heap size的上限。具体的heap size限制因不同设备、不同RAM大小而各有差异。如果app已经到了heap的限制大小并且再尝试分配内存的话，会引起OutOfMemoryError的错误。  
2. 可以通过getMemoryClass()来查询当前设备的heap size限制大小是多少。 

## 切换应用  
1. Android并不会在用户切换不同应用时候做交换内存的操作。Android会把那些不包含foreground组件的进程放到LRU cache中。例如，当用户刚开始启动了一个应用，系统会为它创建了一个进程，但是当用户离开这个应用，此进程并不会立即被销毁。系统会把这个进程放到cache中，如果用户后来再回到这个应用，此进程就能够被完整恢复，从而实现应用的快速切换。  
2. 当系统开始进入低内存状态时，它会由系统根据LRU的规则与其他因素选择综合考虑之后决定杀掉某些进程，回收一些内存。  

### 应用该如何管理内存   
1. 正确使用Service  
* 当你启动一个service，系统会倾向为了保留这个service而一直保留service所在的进程。
* 当Service不执行任务时，记得停止掉。 
* 使用IntentService， 它会在处理完交代给它的intent任务之后尽快结束自己。
2. 当UI隐藏时释放内存  
    当用户切换到其它应用并且你的应用 UI不再可见时，你应该释放你的应用UI上所占用的所有内存资源。为了能够接收到用户离开你的UI时的通知，需要实现Activtiy类里面的onTrimMemory()回调方法来监听到TRIM_MEMORY_UI_HIDDEN级别的回调，此时意味着UI已经隐藏，应该释放那些仅仅被你的UI使用的资源。
3. 当内存紧张时释放部分内存  
    在你的app生命周期的任何阶段，onTrimMemory的回调方法同样可以告诉你整个设备的内存资源已经开始紧张。你应该根据onTrimMemory回调中的内存级别来进一步决定释放哪些资源。
4. 避免bitmaps的浪费
    当你加载一个bitmap时，仅仅需要保留适配当前屏幕设备分辨率的数据即可，如果原图高于你的设备分辨率，需要做缩小的动作。请记住，增加bitmap的尺寸会对内存呈现出2次方的增加，因为X与Y都在增加。
5. 使用优化的数据容器
    利用Android Framework里面优化过的容器类，例如SparseArray, SparseBooleanArray, 与 LongSparseArray。 通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效在于他们避免了对key与value的autobox自动装箱，并且避免了装箱后的解箱。
6. 请注意内存开销  
* Enums的内存消耗通常是static constants的2倍。你应该尽量避免在Android上使用enums。
* 在Java中的每一个类(包括匿名内部类)都会使用大概500 bytes。
* 每一个类的实例花销是12-16 bytes。
* 往HashMap添加一个entry需要额一个额外占用的32 bytes的entry对象。
7. 避免使用依赖注入框架
    那些框架会通过扫描你的代码执行许多初始化的操作，这会导致你的代码需要大量的RAM来mapping代码，而且mapped pages会长时间的被保留在RAM中。  
8. 谨慎使用第三方libraries  
9. 使用ProGuard来剔除不需要的代码  
10. 对最终的APK使用zipalign  
11. 使用多进程  
    > 有一个更高级的技术可以帮助你的app管理内存使用：通过把你的app组件切分成多个组件，运行在不同的进程中。具体通过在manifest文件中声明’android:process’属性来实现某个组件运行在另外一个进程的操作。 
12. 频繁的垃圾回收（GC）也影响应用的性能   

### 内存、GC和性能 的关系  
1. Android系统里面有一个Generational Heap Memory的模型，系统会根据内存中不同的内存数据类型分别执行不同的GC操作。例如，最近刚分配的对象会放在Young Generation区域，这个区域的对象通常都是会快速被创建并且很快被销毁回收的，同时这个区域的GC操作速度也是比Old Generation区域的GC操作速度更快的。当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后到Permanent Generation区域。  
2. 执行GC操作的时候，所有线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行，通常来说，单个的GC并不会占用太多时间，但是大量不停的GC操作则会显著占用帧间隔时间(16ms)。如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了。   
3. 导致GC频繁执行有两个原因：

    Memory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。  
    瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。  
4. 在短时间内，同一个栈中不断进出的相同对象。这是内存抖动的典型信号之一  
5. 避免在for循环里面分配对象占用内存，需要尝试把对象的创建移到循环体之外  
6. 自定义View中的onDraw方法也需要引起注意，每次屏幕发生绘制以及动画执行过程中，onDraw方法都会被调用到，避免在onDraw方法里面执行复杂的操作，避免创建对象。对于那些无法避免需要创建对象的情况，我们可以考虑对象池模型，通过对象池来解决频繁创建与销毁的问题，但是这里需要注意结束使用之后，需要手动释放对象池中的对象。  

### 内存泄漏  
1. 内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了宝贵的内存空间。显然，这还使得每级Generation的内存区域可用空间变小，GC就会更容易被触发，从而引起性能问题。  

### 内存监控手段  
1. Android Studio中的Memory Monitor可以很好的帮助我们查看程序的内存使用情况。  
    > 方式内存抖动的地方就是发生频繁垃圾回收，而这些都是对应一个GC Event  
    > 发生内存抖动的原因见上面所说
    > 如果Memory Monitor中内存突然冒高，说明有大对象分配  
2. 使用Android sdk tools文件夹中的monitor工具，使用里面的Heap Viewer的功能，我们可以看到当前进程中的Heap Size的情况，分别有哪些类型的数据，占比是多少  
3. 使用Monitor工具中的Allocation Tracker功能来查看在短时间内，同一个栈中不断进出的相同对象。这是内存抖动的典型信号之一

 

### 性能监测根据  
## traceview   
1. TraceView工具能做什么？  
    简单一点来说就是我们能找到频繁被调用的方法，也能找到执行非常耗时的方法，前者可能会造成Cpu频繁调用，手机发烫的问题，后者就是卡顿的问题
2. traceview中两种方法
    inclusive time：指方法执行时间以及内部其他方法执行时间之和
    exclusive time：指方法本身执行时间
3. traceview面板：
    Parents:调用该方法的父类方法
    Children:该方法调用的子类方法
4. https://www.kancloud.cn/digest/itfootballprefermanc/100911









